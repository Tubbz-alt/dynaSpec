#' Create scrolling dynamic spectrograms
#' 
#' \code{scrolling_spectro} create videos of single row spectrograms scrolling from right to left sync'ed with sound.
#' @usage scrolling_spectro(wave, file.name = "scroll.spectro.mp4", hop.size = 11.6, wl = NULL, 
#' ovlp = 50, flim = NULL, speed = 1, keep.pitch = TRUE, fps = 50, 
#' t.display = 1.5, fix.time = TRUE, res = 70, 
#' width = 700, height = 400, parallel = 1, pb = TRUE,
#'  play = TRUE, ...)
#' @param wave object of class 'Wave'.
#' @param file.name Character string with the name of the output video file. Must include the .mp4 extension. Default is 'scroll.spectro.mp4'.
#' @param hop.size A numeric vector of length 1 specifying the time window duration (in ms). Default is 11.6 ms, which is equivalent to 512 wl for a 44.1 kHz sampling rate. Ignored if 'wl' is supplied.
#' @param wl A numeric vector of length 1 specifying the window length of the spectrogram, default 
#' is NULL. If supplied, 'hop.size' is ignored.
#' @param ovlp Numeric vector of length 1 specifying the percent overlap between two 
#'   consecutive windows, as in \code{\link[seewave]{spectro}}. Default is 50.
#' @param flim A numeric vector of length 2 specifying  limits in the frequency axis (in kHz). Default is \code{NULL} (which means from 0 to Nyquist frequency).  
#' @param speed Numeric vector of length 1 indicating the speed at which the sound file will be reproduced (default is 1, normal speed). Values < 1 (but higher than 0) slow down while values > 1 speed up.
#' @param keep.pitch Logical argument to control if pitch is kept when speed is modified (speed != 1). Default is \code{TRUE}.
#' @param fps Numeric vector of length 1 specifying the number of frames per second.
#' @param t.display Numeric vector of length 1 specifying the time range displayed in the spectrogram.
#' @param fix.time Logical argument to control if the time axis moves along with the spectrogram or remains fixed. Default is \code{TRUE} (fixed).
#' @param res Numeric vector of length 1 specifying the resolution of the image files (see \code{\link[grDevices]{tiff}}). Default is 70.
#' @param width Numeric vector of length 1 specifying width of the video frame in pixels (see \code{\link[grDevices]{tiff}}). Default is 700.
#' @param height Numeric vector of length 1 specifying height of the video frame in pixels (see \code{\link[grDevices]{tiff}}). Default is 400.
#' @param res Numeric vector of length 1 specifying the resolution of the image files (see \code{\link[grDevices]{tiff}}).
#' @param parallel Numeric vector of length 1. Controls whether parallel computing is applied by specifying the number of cores to be used. Default is 1 (i.e. no parallel computing).
#' @param pb Logical argument to control if progress bar is shown. Default is \code{TRUE}.
#' @param play Logical argument to control if the video is played after generated. Default is \code{TRUE}.
#' @param ... Additional arguments to be passed to \code{\link[seewave]{spectro}} for customizing spectrograms. Note that 'scale' cannot be included.
#' @return A video file in mp4 format in the working directory with the scrolling spectrogram.
#' @export
#' @name scrolling_spectro
#' @details The function creates videos (mp4 format) of single row spectrograms scrolling from right to left. The audio is sync'ed with the spectrograms. 
#' @seealso 
#' @examples
#' \dontrun{
#' # load example data
#' data(list = c("Phae.long1"))
#' 
#' # run function
#' scrolling_spectro(wave = w, wl = 300, ovlp = 90, 
#' fps = 50, t.display = 1.5, collevels = seq(-40, 0, 5),
#'  pal = reverse.heat.colors, grid = FALSE, flim = c(1, 10), 
#'  res = 120)
#' }
#' 
#' @author Marcelo Araya-Salas (\email{marceloa27@@gmail.com}) 
#' @references {
#' Araya-Salas M & M. Wilkins. (2020), *dynaSpec: dynamic spectrogram visualizations in R*. R package version 1.0.0.
#' }

scrolling_spectro <- function(wave, file.name = "scroll.spectro.mp4", hop.size = 11.6, wl = NULL, ovlp = 50, flim = NULL, speed = 1, keep.pitch = TRUE, fps = 50, t.display = 1.5, fix.time = TRUE, res = 70, width = 700, height = 400, parallel = 1, pb = TRUE, play = TRUE, ...)
{

  # change speed
  if (speed != 1)
  { 
    # change speed
    wave@samp.rate <- wave@samp.rate * speed
    if (!keep.pitch) shift_wave <- wave
    
    # fix shift frequency
    wave <- seewave::lfs(wave = wave, shift =  1000 / speed, output = "Wave")
    
    # normalize
    wave <- tuneR::normalize(wave, "16")
    }
  # hopsize  
  if (!is.numeric(hop.size) | hop.size < 0) stop("'parallel' must be a positive number") 
  
  # If parallel is not numeric
  if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1") 
  if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
  
  # add silence
  wave_sil <- seewave::pastew(wave2 = tuneR::silence(duration = t.display / 2, samp.rate = wave@samp.rate,
                               xunit = "time"), wave1 = wave, f = wave@samp.rate,
               output = "Wave")

  wave_sil <- seewave::pastew(wave1 = tuneR::silence(duration = t.display / 2, samp.rate = wave_sil@samp.rate,
                               xunit = "time"), wave2 = wave_sil, f = wave_sil@samp.rate,
               output = "Wave")
  
  # resample to 44.1 kHz
  if (wave_sil@samp.rate != 44100)
  wave_sil <- seewave::resamp(wave = wave_sil, f = wave_sil@samp.rate, g = 44100, output = "Wave")
  
  # adjust wl based on hope.size
  if (is.null(wl))
    wl <- round(wave_sil@samp.rate * hop.size / 1000, 0)
  
  # make wl even if odd
  if (!(wl %% 2) == 0) wl <- wl + 1
  
  # make width and height even if odd
  if (!(width %% 2) == 0) width <- width + 1
  if (!(height %% 2) == 0) height <- height + 1
  
  # number of frames
  frames <- round(seewave::duration(wave) * fps, 0) 
  
  # time increase between frames
  step_time <- (seewave::duration(wave_sil) - t.display) / (frames - 1)
  
  # make vector with name of images
  img_names <- paste0(sprintf(paste0("%0",nchar(frames) + 1, "d"), 1:frames), ".temp.img.tiff")

  if (is.null(flim)) # flim on original wave
    flim <- c(0, wave@samp.rate / 2000)

  # reset margins at the end
  opar <- par
  on.exit(par(opar))
  
  # save full spectrogram of wave
  grDevices::png(filename = file.path(tempdir(), "temp.full.spectro.png"), height = height, width = width * seewave::duration(wave_sil) / t.display, res = res)
  
  par(mar = rep(0, 4))
  
  # plot spectro
  suppressMessages(seewave::spectro(wave = wave_sil, f = wave_sil@samp.rate, wl = wl, ovlp = ovlp, axisX = FALSE, axisY = FALSE, scale = FALSE, flim = flim, ...))
  
  # close plot
  dev.off()
  
  # read image
  spc_img <- png::readPNG(source = file.path(tempdir(), "temp.full.spectro.png"))
  
  # calculate pixels per second
  px.per.s <- dim(spc_img)[2] / seewave::duration(wave_sil)
  
  # set pb options 
  pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
  
  # set clusters for windows OS
  if (Sys.info()[1] == "Windows" & parallel > 1)
    cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
  
  #loop to create image files 
  out <- pbapply::pblapply(1:frames, function(x){
    
    # time limit
    tlim <- c((x - 1) * step_time, (x - 1) * step_time + t.display)
    
    # pixel limt
    img.x.lim <- round(tlim * px.per.s, 0)
    
    # start tiff device
    grDevices::tiff(file.path(tempdir(), img_names[x]),res = res, width = width, height = height)
    
    par(mar =  c(4.2, 4.2, 1, 1) + 0.1)
    
    plot(0,0, xlim = if(fix.time) c(0, t.display) else tlim, ylim = flim, xlab = "Time (s)", ylab = "Frequency (kHz)", xaxs = "i", yaxs = "i")
    
    plt <- par("plt")
    
    grid::grid.raster(spc_img[, img.x.lim[1]:img.x.lim[2], ], x = plt[1], y =  plt[3], height = plt[4] - plt[3], width= plt[2] - plt[1], hjust = 0, vjust = 0)
    
    abline(v = if(fix.time) t.display / 2 else tlim[1] + (t.display / 2), lty = 2, col = "skyblue", lwd = 2)
  
    dev.off()
  })
  
  # temporary file names
  temp.audio <- file.path(tempdir(), "audio.scroll.spectro.wav")
  temp.video <- file.path(tempdir(), "scroll.spectro.temp.mp4")
  
  # save audio file
  suppressWarnings(tuneR::writeWave(object = if (!keep.pitch) shift_wave else wave, filename = temp.audio, extensible = FALSE))
  
  # put together call for ffmpeg
  cll1 <- paste0("ffmpeg -framerate ", fps, " -i ", tempdir(), "/", paste0("%0",nchar(frames) + 1, "d.temp.img.tiff")," -c:v libx264 -profile:v high -crf 2 -pix_fmt yuv420p -y ", temp.video)
  
  # run ffmpeg to create video
  out1 <- system(cll1, intern = TRUE, ignore.stdout = TRUE, ignore.stderr = TRUE)
  
  # add audio
  cll2 <- paste0("ffmpeg -i ", temp.video, " -i ", temp.audio, " -vcodec libx264 -acodec libmp3lame -shortest -y ", file.name)
  
  # run ffmpeg to add audio
  out2 <- system(cll2, intern = TRUE, ignore.stdout = TRUE, ignore.stderr = TRUE)
  
  # remove temporary files
  unlink(c(temp.video, temp.audio, list.files(path = tempdir(), full.names = TRUE, pattern = "\\.temp.img.tiff$")))
  
  if (play)
  if (.Platform["OS.type"] == "windows") {
    shell.exec(file.name)
  }
  else {
    system(paste(Sys.getenv("R_BROWSER"), file.name), ignore.stdout = TRUE, 
           ignore.stderr = TRUE)
  }
  
}
